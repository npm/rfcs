# Signed Packuments

## Summary

Add support for validating packument signatures in the npm cli.

## Motivation

Today, there is no way to verify a packument's origin. This results in users unintentionally installing packages from the wrong source due to misconfigured npmrcs. This also allows caching layers, mirrors, and internal registries to tamper with files undetected.

## Detailed Explanation

We would like to give registries the ability to sign their packuments and give clients the ability to validate the bits they receive over the wire against those signatures.

Packuments contain the integrity hashes of package tarballs. If a packument can be validated, the hash of the tarball is then trusted. This means signatures for tarballs are not necessary.

## Rationale and Alternatives

### [Notary](https://github.com/theupdateframework/notary)

Notary is a project that allows anyone to have trust over arbitrary collections of data. This would allow us to validate the data uploaded to the npm registry against the _author's_ public keys. However, I believe, today packuments are generated by the registry meaning all packuments are generated by the same author.

Notary may be an effective tool moving forward for validating that packages originated from a trusted/authorized author, irrespective of what registry a package was initially uploaded to, but that isn't the problem we are trying to solve here.

### External tooling

In order to validate that we used valid packuments for an installation, we could:

  1) first do the full install
  2) Check the cache for the contents of the HTTP responses of each module's packument using something like `pacote`
  3) Follow up with another set of requests to download the signature files
  4) Validate the signatures against the set of packuments in `cacache`

This pushes trusting the result of an installation into user land as opposed to being able to trust the `npm` cli. We should aim for `npm` to have solid security baked in, not offload that to external tooling.

## Implementation

### `.npmrc`

```
packument-signature-validate: false
packument-signature-key: https://keybase.io/npmregistry/pgp_keys.asc
```

`packument-signature-validate` - validate signatures of the packuments it receives against a public key (defaults to `false`). Ideally we could default this to `true` at some point in the future but would need ecosystem support and a deprecation cycle to ensure compatibility with existing mirrors and private registries. When this is set to true, the cli will check the an HTTP header (`x-npm-signature`) for the packument's signature. If the header is missing, it makes a separate HTTP request to `/[url].sig`. Today mirroring the npm registry (for an in-network cache) can be done with a simple file server. While including the signature as a header saves a request, it requires that the server hosting the registry be able to generate that header. Having a file based signature gives us a way to remain compatible with these simple mirroring solutions.
`packument-signature-key` - The key to validate packuments against (defaults to npm's public key).

## Prior Art

Debian's archive signing key is used to verify that registry contents have not been tampered with: https://ftp-master.debian.org/keys.html

## Unresolved Questions

### Support aggregate registries

Private registry solutions provide aggregate registries (Artifactory calls these virtual repositories). In this case, it's possible to have multiple keys for the same registry url since the packuments may be coming from different registries.

Some options:

* We could add multi-key support to this proposal.
* We could leave this up to private registries to support (I.e. resign all packuments with a single key)

### Provide freshness guarantees

With the current proposal, an attacker could:

1) fetch a packument for a package and hold onto it
2) wait for a vulnerability to be patched for a package
3) begin delivering the stale packument to prevent clients from receiving the fix
4) exploit the vulnerability
